// SPDX-License-Identifier: LicenseRef-PATO-ESEO

/**
 * @file strategy_manager.c
 * @brief Source file for the Strategy Manager module.
 *
 * @author
 * ForcePushRebels ‚Äì PATO Project (collective contributor)  
 * Uriel Fodong <uriel.fodong@reseau.eseo.fr> (individual contributor)
 *
 * @version 1.0.0
 *
 * @copyright
 * ¬© 2025 ESEO ‚Äì All rights reserved.
 *
 * @par License
 * PATO ESEO License (see LICENSE.md)
 */

#include <assert.h>
#include <stdlib.h>

#include "../../helpers/util_macros.h"

#define STRATEGY_MANAGER_IMPL_VERSION VER(1, 0, 0)
#include "../include/strategy_manager.h"
#include "../../StrategyWrapper/strategy_wrapper.h"

#include "../../symbols/ret_codes.h"
#include "../../common/supervisor/supervisor.h"

#include "../../config.h"
#include "xLog.h"

#define LOG_TAG "StrategyManager"

#define config_launcher__giveStrat(listStratName)  // TODO

#define supervisor__giveEndCondition(listEndCondition) // TODO

static void print_colored_grid(StrategyManager *self, seq_t *path, size_t path_len);

struct strategy_manager_s
{
	// TODO Ajouter √† la conception
	StrategyWrapper **listStrat;
	// TODO Ajouter √† la conception
	int currentStrategyID; // ID de la strat√©gie actuellement suivie
	int listStratLen;

	Status status;

	mat_t *matrix;
	seq_t *sequence;

	// TODO Ajouter √† la conception
	// FIXME time_t Timer;
	struct timespec start_time, end_time;
};

__attribute__((unused)) // ‚¨ÖÔ∏è √Ä retirer. Lorsque la fonction est utilis√©e
StrategyManager *strategy_manager__create()
{
	/* ===== Pr√©conditions ===== */
	X_ASSERT(true); // ‚¨ÖÔ∏è √Ä conserver. Indique explicitement qu'il n'y a pas de pr√©condition

	X_LOG_TRACE("entering strategy_manager__create()");

	/* ===== Variables locales ===== */
	StrategyManager *strategyManager; // ‚¨ÖÔ∏è √Ä remplacer. malloc/calloc pour la persistence

	/* ===== Logique principale ===== */
	strategyManager = malloc(sizeof(StrategyManager)); // ‚¨ÖÔ∏è Alloue dynamiquement un StrategyManager

	strategyManager->listStrat = malloc(sizeof(StrategyWrapper) * MAX_WRAPPER_PER_MANAGER);
	strategyManager->listStratLen = 0;

	strategyManager->matrix = malloc(sizeof(mat_t) * MAP_SIZE);
	strategyManager->sequence = malloc(sizeof(seq_t) * MAP_SIZE * MAP_SIZE);

	X_LOG_TRACE("exiting strategy_manager__create()");

	/* ===== Postconditions ===== */
    // X_ASSERT(strategyManager != NULL); // ‚¨ÖÔ∏è √Ä d√©commenter. Pour les plus t√©m√©raires

	return strategyManager;
}

__attribute__((unused)) // ‚¨ÖÔ∏è √Ä retirer. Lorsque la fonction est utilis√©e
void strategy_manager__delete(StrategyManager *self)
{
	/* ===== Pr√©conditions ===== */
	X_ASSERT(self != NULL); // ‚¨ÖÔ∏è √Ä conserver. D√©sactiv√© si NDEBUG est d√©fini (build release)

	UNUSED(self); // ‚¨ÖÔ∏è √Ä retirer. D√®s que 'self' est utilis√© en dehors des assert()

	X_LOG_TRACE("entering strategy_manager__delete()");

	/* ===== Variables locales ===== */
    // D√©clare les variables temporaires

	/* ===== Logique principale ===== */
	free(self); // ‚¨ÖÔ∏è Lib√®re la m√©moire allou√©e pour le StrategyManager

	X_LOG_TRACE("exiting strategy_manager__delete()");

	/* ===== Postconditions ===== */
    // X_ASSERT(strategyManager == NULL); // ‚¨ÖÔ∏è √Ä d√©commenter. Quand le SAFE_FREE() est utilis√©

	return; // ‚¨ÖÔ∏è √Ä conserver. Retour explicite (void)
}

void strategy_manager__addStrategyWrapper(StrategyManager *self, StrategyWrapper *strategyWrapper)
{	
	self->listStrat[self->listStratLen++] = strategyWrapper;	
}

void strategy_manager__setMap(StrategyManager *self)
{
	map_engine_get_map(self->matrix);

	strategy_wrapper__bindMap(self->listStrat[self->currentStrategyID], self->matrix);
}

__attribute__((unused)) // ‚¨ÖÔ∏è √Ä retirer. Lorsque la fonction est utilis√©e
void strategy_manager__askStrat(StrategyManager *self)
{
	/* ===== Pr√©conditions ===== */
	X_ASSERT(self != NULL); // ‚¨ÖÔ∏è √Ä conserver. D√©sactiv√© si NDEBUG est d√©fini (build release)

	UNUSED(self); // ‚¨ÖÔ∏è √Ä retirer. D√®s que 'self' est utilis√© en dehors des assert()

	/* ===== Variables locales ===== */
    // D√©clare les variables temporaires

	X_LOG_TRACE("entering strategy_manager__askStrat()");

	/* ===== Logique principale ===== */
	char * listStratName;
	config_launcher__giveStrat(listStratName)  // üìå

	X_LOG_TRACE("exiting strategy_manager__askStrat()");

	/* ===== Postconditions ===== */
	// V√©rifie les invariants apr√®s logique

	return; // ‚¨ÖÔ∏è √Ä conserver. Retour explicite (void)
}

__attribute__((unused)) // ‚¨ÖÔ∏è √Ä retirer. Lorsque la fonction est utilis√©e
void strategy_manager__giveIDStrategieToFollow(StrategyManager *self, int idStrat)
{
	/* ===== Pr√©conditions ===== */
	X_ASSERT(self != NULL); // ‚¨ÖÔ∏è √Ä conserver. D√©sactiv√© si NDEBUG est d√©fini (build release)

	UNUSED(self); // ‚¨ÖÔ∏è √Ä retirer d√®s que 'self' est utilis√© en dehors des assert()
	UNUSED(idStrat); // ‚¨ÖÔ∏è √Ä retirer d√®s que 'idStrat' est utilis√© dans la logique

	X_LOG_TRACE("entering strategy_manager__giveIDStrategieToFollow()");

	/* ===== Variables locales ===== */
    // D√©clare les variables temporaires

	/* ===== Logique principale ===== */
	self->currentStrategyID = idStrat;
	supervisor__giveEndCondition(listEndCondition); // üìå

	X_LOG_TRACE("exiting strategy_manager__giveIDStrategieToFollow()");

	/* ===== Postconditions ===== */
	// V√©rifie les invariants apr√®s logique

	return; // ‚¨ÖÔ∏è √Ä conserver. Retour explicite (void)
}

__attribute__((unused)) // ‚¨ÖÔ∏è √Ä retirer. Lorsque la fonction est utilis√©e
void strategy_manager__startMove(StrategyManager *self)
{
	/* ===== Pr√©conditions ===== */
	X_ASSERT(self != NULL); // ‚¨ÖÔ∏è √Ä conserver. D√©sactiv√© si NDEBUG est d√©fini (build release)

	UNUSED(self); // ‚¨ÖÔ∏è √Ä retirer. D√®s que 'self' est utilis√© en dehors des assert()

	X_LOG_TRACE("entering strategy_manager__startMove()");

	/* ===== Variables locales ===== */
	// D√©clare les variables temporaires

	/* ===== Logique principale ===== */
	/*
		TODO : D√©marrer un d√©placement bas√© sur la strat√©gie courante.
		       Cette fonction peut :
		       - Lire self->currentStrategyID ou une structure de mouvement
		       - Initialiser un mouvement (ex : appel moteur, consigne de distance/vitesse)
		       - Changer l'√©tat interne : self->isMoving = true;

		       Exemple :
		           motion_controller__start(self->motion);
		           self->isMoving = true;
	*/

	X_LOG_TRACE("exiting strategy_manager__startMove()");

	/* ===== Postconditions ===== */
	// V√©rifie les invariants apr√®s logique

	return; // ‚¨ÖÔ∏è √Ä conserver. Retour explicite (void)
}

__attribute__((unused)) // ‚¨ÖÔ∏è √Ä retirer. Lorsque la fonction est utilis√©e
void strategy_manager__endMove(StrategyManager *self)
{
	/* ===== Pr√©conditions ===== */
	X_ASSERT(self != NULL); // ‚¨ÖÔ∏è √Ä conserver. D√©sactiv√© si NDEBUG est d√©fini (build release)

	UNUSED(self); // ‚¨ÖÔ∏è √Ä retirer. D√®s que 'self' est utilis√© en dehors des assert()

	X_LOG_TRACE("entering strategy_manager__endMove()");

	/* ===== Variables locales ===== */
    // D√©clare les variables temporaires

	/* ===== Logique principale ===== */
	/*
		TODO : G√©rer la fin d'un d√©placement strat√©gique.
		       Cette fonction pourrait :
		       - Arr√™ter proprement les moteurs ou contr√¥leurs de mouvement
		       - Mettre √† jour l'√©tat interne : self->isMoving = false;
		       - Notifier le syst√®me ou encha√Æner vers la prochaine action

		       Exemple :
		           motion_controller__stop(self->motion);
		           self->isMoving = false;
	*/

	X_LOG_TRACE("exiting strategy_manager__endMove()");

	/* ===== Postconditions ===== */
	// V√©rifie les invariants apr√®s logique

	return; // ‚¨ÖÔ∏è √Ä conserver. Retour explicite (void)
}

__attribute__((unused)) // ‚¨ÖÔ∏è √Ä retirer. Lorsque la fonction est utilis√©e
bool strategy_manager__alertWallNear(StrategyManager *self)
{
	/* ===== Pr√©conditions ===== */
	X_ASSERT(self != NULL); // ‚¨ÖÔ∏è √Ä conserver. D√©sactiv√© si NDEBUG est d√©fini (build release)

	UNUSED(self); // ‚¨ÖÔ∏è √Ä retirer. D√®s que 'self' est utilis√© en dehors des assert()

	X_LOG_TRACE("entering strategy_manager__alertWallNear()");

	/* ===== Variables locales ===== */
	bool ret = RET_NOT_IMPL_BOOL; // ‚¨ÖÔ∏è "Rater-vite". Initialis√© par un code d'erreur (prog d√©fensive)

	/* ===== Logique principale ===== */
	/*
		TODO : Impl√©menter la logique pour d√©tecter si un mur est proche.
		Probablement via les donn√©es de self->Timer ou capteurs associ√©s.
	*/

	X_LOG_TRACE("exiting strategy_manager__alertWallNear()");

	/* ===== Postconditions ===== */
	// V√©rifie les invariants apr√®s logique

	return ret; // ‚¨ÖÔ∏è √Ä remplacer par la vraie valeur de retour une fois impl√©ment√©
}

__attribute__((unused)) // ‚¨ÖÔ∏è √Ä retirer. Lorsque la fonction est utilis√©e
void strategy_manager__alertEndConditionReach(StrategyManager *self)
{
	/* ===== Pr√©conditions ===== */
	X_ASSERT(self != NULL); // ‚¨ÖÔ∏è √Ä conserver. D√©sactiv√© si NDEBUG est d√©fini (build release)

	UNUSED(self); // ‚¨ÖÔ∏è √Ä retirer. D√®s que 'self' est utilis√© en dehors des assert()

	X_LOG_TRACE("entering strategy_manager__alertEndConditionReach()");

	/* ===== Variables locales ===== */
    // D√©clare les variables temporaires

	/* ===== Logique principale ===== */
	/*
		TODO : Impl√©menter le traitement lorsqu'une condition de fin est atteinte.
		       Par exemple :
		       - Marquer un drapeau interne indiquant que l'objectif est atteint
		       - Passer √† une autre strat√©gie ou arr√™ter le syst√®me
		       - Notifier un autre module (logique d‚Äô√©tat ou communication)
		       Exemple :
		           self->hasReachedEndCondition = true;
		           strategy_manager__switchToIdle(self);
	*/

	X_LOG_TRACE("exiting strategy_manager__alertEndConditionReach()");

	/* ===== Postconditions ===== */
	// V√©rifie les invariants apr√®s logique

	return; // ‚¨ÖÔ∏è √Ä conserver. Retour explicite (void)
}

__attribute__((unused)) // ‚¨ÖÔ∏è √Ä retirer. Lorsque la fonction est utilis√©e
int strategy_manager__getStatus(StrategyManager *self)
{
	/* ===== Pr√©conditions ===== */
	X_ASSERT(self != NULL); // ‚¨ÖÔ∏è √Ä conserver. D√©sactiv√© si NDEBUG est d√©fini (build release)

	UNUSED(self); // ‚¨ÖÔ∏è √Ä retirer. D√®s que 'self' est utilis√© en dehors des assert()

	X_LOG_TRACE("entering strategy_manager__getStatus()");

	/* ===== Variables locales ===== */
	int ret = RET_NOT_IMPL_INT; // ‚¨ÖÔ∏è "Rater-vite". Initialis√© par un code d'erreur (prog d√©fensive)

	/* ===== Logique principale ===== */
	/*
		TODO : Retourner le statut courant de la strat√©gie.
		       Cela pourrait impliquer :
		       - Lire un champ d'√©tat interne, ex : self->status
		       - √âvaluer l'√©tat courant √† partir de plusieurs flags
		       - Combiner ou normaliser plusieurs √©tats internes

		       Exemple :
		           return self->status;
		           // ou : return strategy_manager__computeStatus(self);
	*/

	X_LOG_TRACE("exiting strategy_manager__getStatus()");

	/* ===== Postconditions ===== */
	// V√©rifie les invariants apr√®s logique

	return ret; // ‚¨ÖÔ∏è Constante temporaire, √† remplacer par un vrai code de statut
}

__attribute__((unused)) // ‚¨ÖÔ∏è √Ä retirer. Lorsque la fonction est utilis√©e
void strategy_manager__reportStatus(StrategyManager *self, MoveReason pilotStatus)
{
	/* ===== Pr√©conditions ===== */
	X_ASSERT(self != NULL); // ‚¨ÖÔ∏è √Ä conserver. D√©sactiv√© si NDEBUG est d√©fini (build release)
	assert(0 <= pilotStatus &&           // ‚¨ÖÔ∏è V√©rifie que pilotStatus est dans la plage valide
	       pilotStatus < MOVE_REASON_NB);

	UNUSED(self); // ‚¨ÖÔ∏è √Ä retirer. D√®s que 'self' est utilis√© en dehors des assert()
	UNUSED(pilotStatus); // ‚¨ÖÔ∏è √Ä retirer. D√®s que 'pilotStatus' est utilis√© en dehors des assert()

	X_LOG_TRACE("entering strategy_manager__reportStatus()");

	/* ===== Variables locales ===== */
    // D√©clare les variables temporaires

	/* ===== Logique principale ===== */
	/*
		TODO : Traiter et reporter le statut re√ßu.
		       Par exemple :
		       - Mettre √† jour un champ interne dans self avec pilotStatus
		       - Envoyer un log ou un √©v√©nement √† un autre module
		       - D√©clencher une action li√©e au changement de statut pilote

		       Exemple pseudo-code :
		           self->lastPilotStatus = pilotStatus;
		           log_info("Pilot status report√© : %d", pilotStatus);
	*/

	X_LOG_TRACE("exiting strategy_manager__reportStatus()");

	/* ===== Postconditions ===== */
	// V√©rifie les invariants apr√®s logique

	return; // ‚¨ÖÔ∏è √Ä conserver. Retour explicite (void)
}

__attribute__((unused)) // ‚¨ÖÔ∏è √Ä retirer. Lorsque la fonction est utilis√©e
void strategy_manager__interlockManuMode(StrategyManager *self)
{
	/* ===== Pr√©conditions ===== */
    X_ASSERT(self != NULL); // ‚¨ÖÔ∏è √Ä conserver. D√©sactiv√© si NDEBUG est d√©fini (build release)

	UNUSED(self); // ‚¨ÖÔ∏è √Ä retirer. D√®s que 'self' est utilis√© en dehors des assert()

	X_LOG_TRACE("entering strategy_manager__interlockManuMode()");

	/* ===== Variables locales ===== */
    // D√©clare les variables temporaires

	/* ===== Logique principale ===== */
    /*
        TODO : Impl√©menter ici la logique d'interverrouillage (interlock) en mode manuel.
        Exemple possible :
            - V√©rifier si mode manuel activ√©
            - Bloquer certaines commandes automatiques
            - Mettre √† jour l'√©tat interne en cons√©quence
    */

	X_LOG_TRACE("exiting strategy_manager__interlockManuMode()");

	/* ===== Postconditions ===== */
	// V√©rifie les invariants apr√®s logique

	return; // ‚¨ÖÔ∏è √Ä conserver. Retour explicite (void)
}

__attribute__((unused)) // ‚¨ÖÔ∏è √Ä retirer. Lorsque la fonction est utilis√©e
void strategy_manager__computeStrat(StrategyManager *self, seq_t *sequence)
{
	/* ===== Pr√©conditions ===== */
    X_ASSERT(self != NULL); // ‚¨ÖÔ∏è √Ä conserver. D√©sactiv√© si NDEBUG est d√©fini (build release)

	UNUSED(self); // ‚¨ÖÔ∏è √Ä retirer. D√®s que 'self' est utilis√© en dehors des assert()

	X_LOG_TRACE("entering strategy_manager__computeStrat()");

	/* ===== Variables locales ===== */
    // D√©clare les variables temporaires

	/* ===== Logique principale ===== */
	strategy_wrapper__prepare(self->listStrat[self->currentStrategyID], self->matrix);

	Point initial = {0, 0}, final = {9, 9};

	strategy_wrapper__execute(self->listStrat[self->currentStrategyID], sequence, &initial, &final);

	print_colored_grid(self, sequence, MAP_SIZE * MAP_SIZE);

	X_LOG_TRACE("exiting strategy_manager__computeStrat()");

	/* ===== Postconditions ===== */
	// V√©rifie les invariants apr√®s logique

	return; // ‚¨ÖÔ∏è √Ä conserver. Retour explicite (void)
}

__attribute__((unused)) // ‚¨ÖÔ∏è √Ä retirer. Lorsque la fonction est utilis√©e
int strategy_manager__startTimer(StrategyManager *self)
{
	/* ===== Pr√©conditions ===== */
    X_ASSERT(self != NULL); // ‚¨ÖÔ∏è √Ä conserver. D√©sactiv√© si NDEBUG est d√©fini (build release)
    // X_ASSERT(self->Timer != NULL); // ‚¨ÖÔ∏è √Ä conserver. D√©sactiv√© si NDEBUG est d√©fini (build release)

	UNUSED(self); // ‚¨ÖÔ∏è √Ä retirer. D√®s que 'self' est utilis√© en dehors des assert()

	X_LOG_TRACE("entering strategy_manager__startTimer()");

	/* ===== Variables locales ===== */
	int ret = RET_NOT_IMPL_INT; // ‚¨ÖÔ∏è "Rater-vite". Initialis√© par un code d'erreur (prog d√©fensive)

	/* ===== Logique principale ===== */
    ret = clock_gettime(CLOCK_MONOTONIC, &self->start_time);

	X_LOG_TRACE("exiting strategy_manager__startTimer()");

	/* ===== Postconditions ===== */
	// assert(ret == RET_OK); // ‚¨ÖÔ∏è √Ä d√©commenter. Pour les plus t√©m√©raires

    return ret;
}

__attribute__((unused)) // ‚¨ÖÔ∏è √Ä retirer. Lorsque la fonction est utilis√©e
int strategy_manager__stopTimer(StrategyManager *self)
{
	/* ===== Pr√©conditions ===== */
    X_ASSERT(self != NULL); // ‚¨ÖÔ∏è √Ä conserver. D√©sactiv√© si NDEBUG est d√©fini (build release)
    // X_ASSERT(self->Timer != NULL); // ‚¨ÖÔ∏è √Ä conserver. D√©sactiv√© si NDEBUG est d√©fini (build release)

	UNUSED(self); // ‚¨ÖÔ∏è √Ä retirer. D√®s que 'self' est utilis√© en dehors des assert()

	X_LOG_TRACE("entering strategy_manager__stopTimer()");

	/* ===== Variables locales ===== */
	int ret = RET_NOT_IMPL_INT; // ‚¨ÖÔ∏è "Rater-vite". Initialis√© par un code d'erreur (prog d√©fensive)

	/* ===== Logique principale ===== */
	clock_gettime(CLOCK_MONOTONIC, &self->end_time);

	X_LOG_TRACE("exiting strategy_manager__stopTimer()");

	/* ===== Postconditions ===== */
	// assert(ret == RET_OK); // ‚¨ÖÔ∏è √Ä d√©commenter. Pour les plus t√©m√©raires

    return ret;
}

int strategy_manager__getTimeElapsed(StrategyManager *self) {
	return self->end_time.tv_sec - self->start_time.tv_sec;
}

__attribute__((unused)) // ‚¨ÖÔ∏è √Ä retirer. Lorsque la fonction est utilis√©e
void strategy_manager__updateStatus(StrategyManager *self, Status status)
{
	/* ===== Pr√©conditions ===== */
	// V√©rifie les invariants avant logique

    X_ASSERT(self != NULL); // ‚¨ÖÔ∏è √Ä conserver. D√©sactiv√© si NDEBUG est d√©fini (build release)

	UNUSED(self); // ‚¨ÖÔ∏è √Ä retirer. D√®s que 'self' est utilis√© en dehors des assert()

	UNUSED(status); // ‚¨ÖÔ∏è √Ä retirer. D√®s que 'status' est utilis√© en dehors des assert()

	X_LOG_TRACE("entering strategy_manager__updateStatus()");

	/* ===== Variables locales ===== */
    // D√©clare les variables temporaires

	/* ===== Logique principale ===== */
	self->status = status;
   
	X_LOG_TRACE("exiting strategy_manager__updateStatus()");

	/* ===== Postconditions ===== */
	// V√©rifie les invariants apr√®s logique

	return; // ‚¨ÖÔ∏è √Ä conserver. Retour explicite (void)
}

#define ROWS 10
#define COLS 10
#define PATH_MAX_LEN MAP_SIZE * MAP_SIZE
static void print_colored_grid(StrategyManager *self, seq_t *path, size_t path_len) {
	int grid[ROWS][COLS] = {0};  // 0: empty, 1: path, 2: obstacle

	// Mark obstacles and path in single loop
	for (int i = 0; i < ROWS; ++i) {
		for (int j = 0; j < COLS; ++j) {
		if (self->matrix[i][j].type == MAP_CELL_WALL) {
			grid[i][j] = 2; // Mark as obstacle
		}
		}
	}

	// Mark path points
	for (size_t i = 0; i < path_len; ++i) {
		int x = path[i][0];
		int y = path[i][1];
		
		if (x >= 0 && x < ROWS && y >= 0 && y < COLS) {
		grid[x][y] = 1; // Mark as path
		}
	}

	// Print column headers
	printf("   ");
	for (int j = 0; j < COLS; ++j) {
		printf("%2d ", j);
	}
	printf("\n");

	// Print separator line
	printf("   ");
	for (int j = 0; j < COLS; ++j) {
		printf("---");
	}
	printf("\n");

	// Print grid with coloring
	for (int i = 0; i < ROWS; ++i) {
		printf("%2d|", i);  // Row label
		for (int j = 0; j < COLS; ++j) {
			switch (grid[i][j]) {
				case 1: // Path
					printf("\033[1;30;47m # \033[0m");  // black on white
					break;
				case 2: // Obstacle
					printf("\033[1;31m @ \033[0m");     // red
					break;
				default:
					printf(" . ");                      // empty
			}
		}
		printf("\n");
	}
	printf("\n");
}
